#include "landmark_factory_acyclic.h"

#include "../option_parser.h"
#include "../plugin.h"

#include "../utils/logging.h"

using namespace std;

namespace landmarks {
LandmarkFactoryAcyclic::LandmarkFactoryAcyclic(const Options &opts)
    : LandmarkFactory(opts),
      lm_factory(opts.get<shared_ptr<LandmarkFactory>>("lm_factory")) {
}

void LandmarkFactoryAcyclic::generate_landmarks(
    const std::shared_ptr<AbstractTask> &task) {
    lm_graph = lm_factory->compute_lm_graph(task);
    unordered_set<LandmarkNode *> acyclic_node_set(lm_graph->number_of_landmarks());
    int removed_edges = 0;
    for (auto &node : lm_graph->get_nodes()) {
        if (acyclic_node_set.find(node.get()) == acyclic_node_set.end())
            removed_edges += loop_acyclic_graph(*node, acyclic_node_set);
    }
    // [Malte] Commented out the following assertion because
    // the old method for this is no longer available.
    // assert(acyclic_node_set.size() == number_of_landmarks());
    utils::g_log << "Removed " << removed_edges
                 << " reasonable or obedient reasonable orders" << endl;
}

int LandmarkFactoryAcyclic::loop_acyclic_graph(
    LandmarkNode &lmn, unordered_set<LandmarkNode *> &acyclic_node_set) {
    assert(acyclic_node_set.find(&lmn) == acyclic_node_set.end());
    int nr_removed = 0;
    list<pair<LandmarkNode *, EdgeType>> path;
    unordered_set<LandmarkNode *> visited =
        unordered_set<LandmarkNode *>(lm_graph->number_of_landmarks());
    LandmarkNode *cur = &lmn;
    while (true) {
        assert(acyclic_node_set.find(cur) == acyclic_node_set.end());
        if (visited.find(cur) != visited.end()) { // cycle
            // find other occurrence of cur node in path
            list<pair<LandmarkNode *, EdgeType>>::iterator it;
            for (it = path.begin(); it != path.end(); ++it) {
                if (it->first == cur)
                    break;
            }
            assert(it != path.end());
            // remove edge from graph
            remove_first_weakest_cycle_edge(cur, path, it);
            //assert(removed);
            ++nr_removed;

            path.clear();
            cur = &lmn;
            visited.clear();
            continue;
        }
        visited.insert(cur);
        bool empty = true;
        for (const auto &child : cur->children) {
            LandmarkNode *child_p = child.first;
            EdgeType edge = child.second;
            if (acyclic_node_set.find(child_p) == acyclic_node_set.end()) {
                path.emplace_back(cur, edge);
                cur = child_p;
                empty = false;
                break;
            }
        }
        if (!empty)
            continue;

        // backtrack
        visited.erase(cur);
        acyclic_node_set.insert(cur);
        if (!path.empty()) {
            cur = path.back().first;
            path.pop_back();
            visited.erase(cur);
        } else
            break;
    }
    assert(acyclic_node_set.find(&lmn) != acyclic_node_set.end());
    return nr_removed;
}

bool LandmarkFactoryAcyclic::remove_first_weakest_cycle_edge(
    LandmarkNode *cur, list<pair<LandmarkNode *, EdgeType>> &path,
    list<pair<LandmarkNode *, EdgeType>>::iterator it) {
    LandmarkNode *parent_p = nullptr;
    LandmarkNode *child_p = nullptr;
    for (auto it2 = it; it2 != path.end(); ++it2) {
        EdgeType edge = it2->second;
        if (edge == EdgeType::reasonable || edge == EdgeType::obedient_reasonable) {
            parent_p = it2->first;
            if (*it2 == path.back()) {
                child_p = cur;
                break;
            } else {
                list<pair<LandmarkNode *, EdgeType>>::iterator child_it = it2;
                ++child_it;
                child_p = child_it->first;
            }
            if (edge == EdgeType::obedient_reasonable)
                break;
            // else no break since o_r order could still appear in list
        }
    }
    assert(parent_p && child_p);
    assert(parent_p->children.find(child_p) != parent_p->children.end());
    assert(child_p->parents.find(parent_p) != child_p->parents.end());
    parent_p->children.erase(child_p);
    child_p->parents.erase(parent_p);
    return true;
}

bool LandmarkFactoryAcyclic::supports_conditional_effects() const {
    return lm_factory->supports_conditional_effects();
}

static shared_ptr<LandmarkFactory> _parse(OptionParser &parser) {
    parser.document_synopsis(
        "Acyclic Landmarks",
        "Makes the landmark graph generated by lm_factory acyclic");
    parser.document_note(
        "Relevant options",
        "");
    parser.add_option<shared_ptr<LandmarkFactory>>("lm_factory");

    _add_options_to_parser(parser);
    Options opts = parser.parse();

    if (parser.dry_run())
        return nullptr;
    else
        return make_shared<LandmarkFactoryAcyclic>(opts);
}

static Plugin<LandmarkFactory> _plugin("lm_acyclic", _parse);
}
